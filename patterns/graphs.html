<!DOCTYPE html>
<html lang="en"><head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Patterns Graphs | Dmitry Babichev’s webpage</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Patterns Graphs" />
<meta name="author" content="Dmitry Babichev" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems." />
<meta property="og:description" content="Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems." />
<meta property="og:site_name" content="Dmitry Babichev’s webpage" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Patterns Graphs" />
<script type="application/ld+json">
{"url":"/patterns/graphs","@type":"WebPage","headline":"Patterns Graphs","author":{"@type":"Person","name":"Dmitry Babichev"},"description":"Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Dmitry Babichev's webpage" />
    






  



</head>

    
    <!-- for mathjax support -->
    
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dmitry Babichev&#39;s webpage</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/codeforces%20problems/">Codeforces</a><a class="page-link" href="/leetcode%20problems/">Leetcode problems</a><a class="page-link" href="/binarysearch%20problems/">BinarySearch</a><a class="page-link" href="/coding%20ideas/">Patterns</a><a class="page-link" href="/performance%20tricks/">Speed up</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Patterns Graphs</h1>
  </header>

  <div class="post-content">
    <p>Here is a collection of different graph algorithms.</p>

<h4 id="floyd-warshall">Floyd-Warshall</h4>
<p>It will find the shortest paths between all pairs of nodes in $O(n^3)$ time, where $n$ is number of nodes. Sanity check here means that we have cycles with negative weigth.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">floyd_warshall</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="s">"inf"</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
        <span class="n">pred</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">pred</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
    <span class="s">"""Sanity Check
    for u, v, d in edges:
        if dist[u] + d &lt; dist[v]:
            return None
    """</span>

    <span class="k">return</span> <span class="n">dist</span><span class="p">,</span> <span class="n">pred</span>
</code></pre></div></div>

<h4 id="bellman-ford-algorithm">Bellman-Ford algorithm</h4>
<p>It will find shortest paths from given node to all others, if we can have negative weights, but not negative cycles. Time complexity is $O(mn)$, where $m$ is number of edges and $n$ is number of nodes. Sanity check again is used to find existance of negative loops.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bellman_ford</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s">"inf"</span><span class="p">)]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="n">dist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span>
                <span class="n">pred</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
    <span class="s">"""Sanity Check
    for u, v, d in edges:
        if dist[u] + d &lt; dist[v]:
            return None
    """</span>

    <span class="k">return</span> <span class="n">dist</span><span class="p">,</span> <span class="n">pred</span>
</code></pre></div></div>

<h4 id="strongly-connected-components-tarjan">Strongly Connected Components, Tarjan</h4>

<p>Here is Tarjan algorithm to detect strongly connected components in directed graph. Time and space complexity is $O(E+V)$ (however with quite big constant, like 5-7). Input is directed unweighted graph and output will be list of length $n$, where for each node we have index of SCC.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span> 
   
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>       
    <span class="k">def</span> <span class="nf">SCCU_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span> 
        <span class="bp">self</span><span class="p">.</span><span class="n">disc</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">Time</span> 
        <span class="bp">self</span><span class="p">.</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">Time</span> 
        <span class="bp">self</span><span class="p">.</span><span class="n">Time</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stackMember</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> 
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span> 
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">disc</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> 
                <span class="bp">self</span><span class="p">.</span><span class="n">SCCU_helper</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> 
                <span class="bp">self</span><span class="p">.</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>       
            <span class="k">elif</span> <span class="bp">self</span><span class="p">.</span><span class="n">stackMember</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>  
                <span class="bp">self</span><span class="p">.</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">disc</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> 
  
        <span class="n">w</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="p">.</span><span class="n">disc</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span> 
            <span class="k">while</span> <span class="n">w</span> <span class="o">!=</span> <span class="n">u</span><span class="p">:</span> 
                <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> 
                <span class="bp">self</span><span class="p">.</span><span class="n">comp</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">stackMember</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">SCC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">connections</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">Time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">disc</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>   <span class="c1">#discovery time
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>    <span class="c1">#low link
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">stackMember</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> 
        <span class="bp">self</span><span class="p">.</span><span class="n">st</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">comp</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>     <span class="c1">#component number for each node
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> 
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">disc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> 
                <span class="bp">self</span><span class="p">.</span><span class="n">SCCU_helper</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> 

        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">comp</span>
</code></pre></div></div>

<h4 id="strongly-connected-components-kosaraju">Strongly Connected Components, Kosaraju</h4>
<p>Here is Kosaraju algorithm to evaluate strongly connected components in graph, complexity is also $O(V + E)$.
It will return two pieces of information:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">SCC</code> is list of lists, where in each list we have stronlgy connected component and these components follow the topological sort of graph with components merged to point.</li>
  <li><code class="language-plaintext highlighter-rouge">out</code> is list of length <code class="language-plaintext highlighter-rouge">n</code>, where for each node we have index of connected component.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">kosaraju</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">SCC</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">st</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    
    <span class="k">while</span> <span class="n">st</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="o">~</span><span class="n">x</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">SCC</span> <span class="o">+=</span> <span class="p">[</span><span class="n">S</span><span class="p">[</span><span class="n">d</span><span class="p">:]]</span>
                <span class="k">del</span> <span class="n">S</span><span class="p">[</span><span class="n">d</span><span class="p">:],</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">SCC</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span> <span class="n">P</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="n">P</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)]</span>
            <span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">+=</span> <span class="p">[</span><span class="o">~</span><span class="n">x</span><span class="p">]</span>
            <span class="n">st</span> <span class="o">+=</span> <span class="n">G</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">SCC</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">:</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">SCC</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span>
</code></pre></div></div>

<h4 id="dijkstra-algorithm">Dijkstra Algorithm</h4>

<p>Let $n$ be number of nodes with numbers $0,1,\dots, n-1$ and <code class="language-plaintext highlighter-rouge">edges</code> be edges in form: <code class="language-plaintext highlighter-rouge">from, to, weight</code>. Let <code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">end</code> be nodes between which we want to find minimal distance. Time complexity is $O((E+V)\log V)$, space complexity is $O(E+V)$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="n">heappop</span><span class="p">,</span> <span class="n">heappush</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">Dijkstra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">G</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
            <span class="n">G</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        
        <span class="n">heap</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">)]</span>

        <span class="k">while</span> <span class="n">heap</span><span class="p">:</span>
            <span class="p">(</span><span class="n">min_dist</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">id</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span> <span class="k">return</span> <span class="n">min_dist</span>
            <span class="k">for</span> <span class="n">neibh</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="nb">id</span><span class="p">]:</span>
                <span class="n">cand</span> <span class="o">=</span> <span class="n">min_dist</span> <span class="o">+</span> <span class="n">weight</span>
                <span class="k">if</span> <span class="n">cand</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">neibh</span><span class="p">]:</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">neibh</span><span class="p">]</span> <span class="o">=</span> <span class="n">cand</span>
                    <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">neibh</span><span class="p">))</span>
                    
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<h4 id="bridges">Bridges</h4>
<p>Bridges partition graph into biconnected edge components, goal is to find all bridges in graph in $O(V + E)$ time.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">criticalConnections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">connections</span><span class="p">):</span>
        <span class="n">used</span><span class="p">,</span> <span class="n">tin</span><span class="p">,</span> <span class="n">fup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">par</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">used</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">tin</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">timer</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">timer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">par</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">tin</span><span class="p">[</span><span class="n">child</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                    <span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">fup</span><span class="p">[</span><span class="n">child</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">fup</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tin</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span> <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">node</span><span class="p">,</span> <span class="n">child</span><span class="p">])</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>See also leetcode 1192.</p>

<h4 id="articulation-points">Articulation points</h4>
<p><strong>Articulation points</strong> in graphs: such points which being removed break graph into parts. Articulation points partition graph into biconnected vertex components. Here is implementation of classical algorithm. Note that it is very similar to bridges with small differences:</p>

<ol>
  <li>It is <code class="language-plaintext highlighter-rouge">fup[child] &gt;= tin[node]</code> instead of <code class="language-plaintext highlighter-rouge">fup[child] &gt; fup[node]</code>.</li>
  <li>We also keep <code class="language-plaintext highlighter-rouge">children</code>: number of connections and make one more check if <code class="language-plaintext highlighter-rouge">par = -1</code> and number of children more than one (it means, they can not have common descendents), then this is also articulation point.</li>
  <li>Finally, we keep set of articulation points, not list, because one node can be visited several times during traversal.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">ArticulationPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">connections</span><span class="p">):</span>
        <span class="n">used</span><span class="p">,</span> <span class="n">tin</span><span class="p">,</span> <span class="n">fup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">par</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">used</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">tin</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">timer</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">timer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">children</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">par</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">tin</span><span class="p">[</span><span class="n">child</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                    <span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">fup</span><span class="p">[</span><span class="n">child</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">fup</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">tin</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="ow">and</span> <span class="n">par</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">ans</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">children</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">par</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">children</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="n">ans</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>See also problem <strong>0928</strong>, where one of the solutions can use this idea.</p>

<h4 id="topological-sort">Topological sort</h4>

<p>Given graph, check if it is DAG, and if it is, give the correct order of nodes, if not, return $[]$. Here is code which use BFS, time and space complexity is $O(V + E)$. <code class="language-plaintext highlighter-rouge">verts</code> is list of vertices and <code class="language-plaintext highlighter-rouge">E</code> is list of edges.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Topological</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
    <span class="n">pre</span><span class="p">,</span> <span class="n">suc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">pre</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">suc</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">free</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">pre</span><span class="p">),</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">free</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">free</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">out</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">suc</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span>
            <span class="n">pre</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pre</span><span class="p">[</span><span class="n">b</span><span class="p">]:</span> <span class="n">free</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">))</span>
</code></pre></div></div>

<h4 id="euler-path">Euler path</h4>
<p>Given edges of graph, return euler path. Time complexity is <code class="language-plaintext highlighter-rouge">O(E + V)</code>.
Notice that graph is oriented, so it is general case.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Euler</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span> <span class="c1"># net out degree 
</span>    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span> 
        <span class="n">G</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">D</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">D</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span> 
        <span class="k">if</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> 
            <span class="n">x</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">break</span> 

    <span class="n">ans</span><span class="p">,</span> <span class="n">stack</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> 
        <span class="k">while</span> <span class="n">G</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]:</span> 
            <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]].</span><span class="n">pop</span><span class="p">())</span>
        <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="bipartite-graphs">Bipartite graphs</h4>
<p>We can check if graph is bipartite, using usual dfs: either recursive or with stack. With stack it is faster. Time complexity is <code class="language-plaintext highlighter-rouge">O(E + V)</code>.
The result is <code class="language-plaintext highlighter-rouge">color</code>, where <code class="language-plaintext highlighter-rouge">color[i]</code> is 0 or 1 depending on part of graph.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_bipartite</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">color</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">color</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>

            <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">parent</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">color</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">color</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">color</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span>
                        <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">color</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">==</span> <span class="n">color</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
                        <span class="k">return</span> <span class="bp">False</span><span class="p">,</span> <span class="n">color</span>

    <span class="k">return</span> <span class="bp">True</span><span class="p">,</span> <span class="n">color</span>
</code></pre></div></div>

<h4 id="bfs">BFS</h4>
<p>Classical bfs implementation: given graph and starting node, we traverse it with bfs.</p>

<p>Function <code class="language-plaintext highlighter-rouge">layers</code> will return layers, where in first layer distance is <code class="language-plaintext highlighter-rouge">0</code>, then distance is <code class="language-plaintext highlighter-rouge">1</code> and so on.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">used</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">q</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                <span class="n">used</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">layers</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">used</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">q</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">nq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ret</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">q</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                    <span class="n">used</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">nq</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">nq</span>
    <span class="k">return</span> <span class="n">ret</span>
</code></pre></div></div>

<h4 id="bidirectional-bfs">Bidirectional BFS</h4>
<p>We can use bidirectional bfs in the cases, where we need to find the shortest path between nodes <code class="language-plaintext highlighter-rouge">beg</code> and <code class="language-plaintext highlighter-rouge">end</code>.
The idea is to start from both ends and each time choose the end with smaller size of queue. Here we need to be careful: Our invariant, that at each moment of time in our queues we have number of steps (first elements):</p>

<p><code class="language-plaintext highlighter-rouge">[i,i,..., i, i+1, i+1, ..., i+1]</code> and <code class="language-plaintext highlighter-rouge">[j,j,..., j, j+1, j+1, ..., j+1]</code></p>

<p>We extract left element from first queue and we need to check if it is in second. At this moment we for sure know that distance is not more than i + j. However, it can be either i+j or i+j+1, and we need to check all elements with length i to make sure there is no element from second queue with steps <code class="language-plaintext highlighter-rouge">j</code>. So, first time we see that sum of first elements from our queue is more than limit, it means that we finished to process all candidates, so we can return answer.</p>

<p>Also I add empty the part where we look for all neibhours of node <code class="language-plaintext highlighter-rouge">cand</code>. Usually for bidirectional bfs it makes sense not to construct the whole graph (if we have it, why not just use usual bfs), but we construct connections only if needed: on the fly. So, instead of line <code class="language-plaintext highlighter-rouge">neibs = ???</code> you need to create list of all possible neibhours.</p>

<p>Complexity is potentially as in bfs, but for some graphs it works much better, especially if distance is not very big.</p>

<p><strong>Use with care, code is not full and not fully tested</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bfs_bidir</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="n">queue1</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">beg</span><span class="p">)])</span>
    <span class="n">queue2</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">)])</span>
    <span class="n">visited1</span> <span class="o">=</span> <span class="p">{</span><span class="n">beg</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">visited2</span> <span class="o">=</span> <span class="p">{</span><span class="n">end</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>

    <span class="n">limit</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">"inf"</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s">"inf"</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">queue1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue2</span><span class="p">):</span>
            <span class="n">queue1</span><span class="p">,</span> <span class="n">queue2</span> <span class="o">=</span> <span class="n">queue2</span><span class="p">,</span> <span class="n">queue1</span>
            <span class="n">visited1</span><span class="p">,</span> <span class="n">visited2</span> <span class="o">=</span> <span class="n">visited2</span><span class="p">,</span> <span class="n">visited1</span>

        <span class="n">steps</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="o">=</span> <span class="n">queue1</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">steps</span> <span class="o">+</span> <span class="n">queue2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">:</span> <span class="k">return</span> <span class="n">ans</span>

        <span class="k">if</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">visited2</span><span class="p">:</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="n">steps</span> <span class="o">+</span> <span class="n">queue2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">visited1</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">+</span> <span class="n">visited2</span><span class="p">[</span><span class="n">code</span><span class="p">],</span> <span class="n">ans</span><span class="p">)</span>
    
        <span class="n">neibs</span> <span class="o">=</span> <span class="err">???</span>   <span class="c1">#list of all neibs of elem
</span>        <span class="k">for</span> <span class="n">cand</span> <span class="ow">in</span> <span class="n">neibs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cand</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited1</span><span class="p">:</span>
                <span class="n">visited1</span><span class="p">[</span><span class="n">cand</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">queue1</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cand</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<h4 id="lca">LCA</h4>
<p>Given tree, the goal is to answer queries: find LCA of two given nodes. There are at least two different approaches to solve this problem:</p>

<p>1.1 First way is to use Eulerian traversal of graph and then use segment tree/sparse table to answer queries.
Also we need <code class="language-plaintext highlighter-rouge">indxs</code> array\dict where for each value we keep the last occurence of this node (in fact we can keep any occurence, but it is easy to code for the last one).
<strong>full code not tested here</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">self</span><span class="p">.</span><span class="n">arr</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">dep</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>  <span class="c1">#euler path
</span><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">arr</span> <span class="o">+=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">dep</span> <span class="o">+=</span> <span class="p">[</span><span class="n">depth</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">]):</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">arr</span> <span class="o">+=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">dep</span> <span class="o">+=</span> <span class="p">[</span><span class="n">depth</span><span class="p">]</span>

<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">indxs</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">arr</span><span class="p">)}</span>
</code></pre></div></div>

<p>1.2 Another way is to use dfs, where for each node we keep the time when we extracted this node from dfs stack. I think it is more or less equivalent to the previous approach.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">RangeQuery</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="nb">min</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">while</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">_data</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">func</span><span class="p">(</span><span class="n">prev</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">prev</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
            <span class="n">i</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">).</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_data</span><span class="p">[</span><span class="n">depth</span><span class="p">][</span><span class="n">begin</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">_data</span><span class="p">[</span><span class="n">depth</span><span class="p">][</span><span class="n">end</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">depth</span><span class="p">)])</span>


<span class="k">class</span> <span class="nc">LCA</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">time</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">dfs</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">path</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">time</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">nei</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">time</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">P</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
                    <span class="n">dfs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">nei</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">rmq</span> <span class="o">=</span> <span class="n">RangeQuery</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">time</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">time</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">time</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">path</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">rmq</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span>
</code></pre></div></div>

<p>2.0 Use binary lyfting, see Leetcode 1724 solution for more details.</p>


  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Dmitry Babichev</li>
          <li><a class="u-email" href="mailto:dimitry008@gmail.com">dimitry008@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-219856613-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-219856613-1');
</script>

</html>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>