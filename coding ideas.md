---
layout: page
title: Patterns
permalink: /coding ideas/
---

Here is a collection of different algorithms/ideas, which can be useful.

#### Tags
Here is collection of different tags/ideas you should think of when you see new problem. Some of them will help to solve the problem, some of them like linked-list, just to make easier navigation among similar problems.

<table class="tg">
<tbody>
  <tr>
    <th class="tg-0lax"> <a href="/tag/2d-array"> <font color = blue>2d-array</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/2sum"> <font color = blue>2sum</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/accumulate"> <font color = blue>accumulate</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/anagram"> <font color = blue>anagram</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/angle sweep"> <font color = blue>angle sweep</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/array"> <font color = blue>array</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/backtracking"> <font color = blue>backtracking</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/bfs"> <font color = blue>bfs</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/binary indexed tree"> <font color = blue>BIT(tree)</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/binary search"> <font color = blue>binary search</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/bit manipulation"> <font color = blue>bit manipulation</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/bit-dp"> <font color = blue>bit-dp</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/bst"> <font color = blue>bst</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/bucket sort"> <font color = blue>bucket sort</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/counter"> <font color = blue>counter</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/design"> <font color = blue>design</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/dfs"> <font color = blue>dfs</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/digit build"> <font color = blue>digit build</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/divide and conquer"> <font color = blue>divide & conquer</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/dp"> <font color = blue>dp</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/dp-intervals"> <font color = blue>dp-intervals</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/game"> <font color = blue>game</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/generating functions"> <font color = blue>generating functions</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/geometry"> <font color = blue>geometry</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/graph"> <font color = blue>graph</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/graph algo"> <font color = blue>graph algo</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/greedy"> <font color = blue>greedy</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/groupby"> <font color = blue>groupby</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/hash table"> <font color = blue>hash table</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/heap"> <font color = blue>heap</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/inorder traversal"> <font color = blue>inorder traversal</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/interactive"> <font color = blue>interactive</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/intervals"> <font color = blue>intervals</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/kmp"> <font color = blue>kmp</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/line sweep"> <font color = blue>line sweep</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/linked list"> <font color = blue>linked list</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/math"> <font color = blue>math</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/matrix power"> <font color = blue>matrix power</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/meet in the middle"> <font color = blue>meet in the middle</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/merge sort"> <font color = blue>merge sort</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/monotonic deque"> <font color = blue>monotonic deque</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/morris traversal"> <font color = blue>morris traversal</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/palindrome"> <font color = blue>palindrome</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/parser"> <font color = blue>parser</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/permutation"> <font color = blue>permutation</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/queue"> <font color = blue>queue</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/quick select"> <font color = blue>quick select</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/random"> <font color = blue>random</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/recursion"> <font color = blue>recursion</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/rolling hash"> <font color = blue>rolling hash</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/segment tree"> <font color = blue>segment tree</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/simulation"> <font color = blue>simulation</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/sliding window"> <font color = blue>sliding window</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/sort"> <font color = blue>sort</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/stack"> <font color = blue>stack</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/string"> <font color = blue>string</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/suffix array"> <font color = blue>suffix array</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/three pointers"> <font color = blue>three pointers</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/topological sort"> <font color = blue>topological sort</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/tree"> <font color = blue>tree</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/trie"> <font color = blue>trie</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/two pointers"> <font color = blue>two pointers</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/union find"> <font color = blue>union find</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/voting"> <font color = blue>voting</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/sparse table"> <font color = blue>sparse table</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/binary lifting"> <font color = blue>binary lifting</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/connected components"> <font color = blue>connected components</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/LIS"> <font color = blue>LIS</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/sqrt decomposition"> <font color = blue>sqrt decomposition</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/spanning tree"> <font color = blue>spanning tree</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/knuth optimization"> <font color = blue>knuth optimization</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/interactive"> <font color = blue>interactive</font> </a> </th>
    <th class="tg-0lax">  </th>
    <th class="tg-0lax">  </th>
    <th class="tg-0lax">  </th>
  </tr>


</tbody>
</table>

<a href="/tag/2d-array"> <font color = blue> 

#### Useful tricks:

DP arrays
```python
N, M, K = 2, 3, 5
dp1 = [0] * M 
dp2 = [[0] * M for _ in range(N)]    # to create N x M array.
dp3 = [[[0] * M for _ in range(N)] for _ in range(K)]   # K x N x M  array
```

Flatten list of lists
```python
from itertools import chain
equations = [[1,2,3],[4,5]]
list(chain(*equations))
```

Sort with lambda functions
```python
result = [[4,5],[4,6],[6,7],[2,3],[1,1]]
result.sort(key = lambda x: x[0]**2 + x[1]**2): # inplace
result = sorted(result, key = lambda x: x[0]**2 + x[1]**2)
```

#### <a href="/patterns/graphs"> <font color = blue>Graph algorithms</font> </a>
#### <a href="/patterns/number theory"> <font color = blue>Number Theory and Algebra algorithms</font> </a>
#### <a href="/patterns/data structures"> <font color = blue>Data Structures algorithms</font> </a>
#### <a href="/patterns/strings"> <font color = blue>String algorithms</font> </a>
#### <a href="/patterns/geometry"> <font color = blue>Geometry algorithms</font> </a>
#### <a href="/patterns/linear algebra"> <font color = blue>Linear algebra algorithms</font> </a>


### Unsorted


#### Sprague-Grundy theorem
Useful if we have game problem which is sum of games. (add example?)

#### Modular arithmetics and number theory (from e-maxx)
Euler theorem: $a^{\phi(m)} \equiv 1 (m)$, where $(a, m) = 1$, where $\phi(m)$ is Euler function, can be used to find inverse element in $O(\log m)$ time complexity: $a^{-1} = a^{\phi(m)-1} $ However in python 3.8 inverse element is implemented already.

To solve recurrent equations, like fibonacci, we can use fast matrix expontiation with complexity $O(m^3\cdot \log n)$, where $m$ is order of recurrence (2 for fibonacci) and $n$ is term we want to get.

Given module $m$ we can find $1^{-1}, 2^{-1}, \dots, n^{-1}$ for any $n$ in just $O(n)$ time.
```python
r = [1]*(n+1)
for i in range(2, n):
    r[i] = (-m//i*r[m%i]%m)%m
```

For checking all submasks of given masks in $O(3^n)$, check Leetcode problem 1655.


**Bridges** online. If we want to find the number of brides when we change our graph: add edge by edge. There is $O(n\log n + m)$ time complexity algorithm, where $m$ is number of edges (queries) and $n$ is number of nodes. The idea is to use two DSU structures: one for connected components and another for biconnected components.

To find **spanning tree** of graph we can use Prim's algorithm or Kruskal's algorithm (with dsu) with $O(m\log n)$ time complexity. There is also a way to find number of spanning trees with $O(n^3)$ complexity, using Kirchhoff's theorem.

Prufer sequence and Cayley's formula helps to enumerate all spanning trees of full graph as well as number of ways to make graph full, adding minumal number of nodes.

**Euler** path in graph can be found in $O(E)$ time complexity, see Leetcode 0332.

Least common ancestor **LCA** and range minimum query **RMQ**: there are a lot of different ways to solve these problems, with $O(n)$ preprocessing and $O(1)$ time being the best solution.

Maximum flow/Minimum cut algorithms: Edmonds-Karp with $O(VE^2)$ time complexity, Ford-Fulkerson with $O(Ef)$, where $f$ is maximal flow, but it can have infinite loop if weights are not integer. Push-relabel maximum flow with $O(V^2\sqrt{E})$ complexity.

Hungarian algorithm: given matrix of size $n\times n$, we need to put $n$ rooks, which don't beat each other such that sum of all cells they occupy is minumal. There is $O(n^3)$ algorithm.

Kuhn' Algorithm --- Maximum Bipartite Matching, complexity is $O(mn)$.



