---
layout: post
title: Leetcode 0091. Decode Ways
tags: []
---

Let us use dynamic programming for this problem, where we keep `3` values on each step:

1. `dp[0]` is total numbers to decode number `s[:i]`.
2. `dp[1]` is number of ways to decode number `s[:i]`, if it ends with `1` and last digit is **part of 2-digit number**. This is important point.
3. `dp[2]` is number of ways to decode number `s[:i]`, if it ends with `2` and last digit is **part of 2-digit number**.

Now, we need to understand how to update our numbers:
1. For `dp_new[0]` we can have `3` options: if last digit is more than `0`, than we can take it as `1-digit number` (by definition each part is number between 1 and 26). Also, we can take last number as 2-digit number if it starts with `1`: this is exactly `dp[1]`. and if it starts with `2` and last digit is less or equal to `6`.
2. For `dp_new[1]` we have only one option: we need to have last symbol equal to `1`. 
3. Similar for `dp_new[2]`, we need to have last symbol equal to `2`.

**Complexity**: time complexity is `O(n)`: we iterate over each symbol once. Space complexity is `O(1)`.

```python
class Solution:
    def numDecodings(self, s):
        dp = [1, 0, 0]
        for c in s:
            dp_new = [0,0,0]
            dp_new[0]  = (c > '0') * dp[0] + dp[1] + (c <= '6') * dp[2]
            dp_new[1]  = (c == '1') * dp[0]
            dp_new[2]  = (c == '2') * dp[0]
            dp = dp_new
        return dp[0]
```
