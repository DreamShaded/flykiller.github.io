---
layout: post
title: Leetcode 0072. Edit Distance
permalink: /Leetcode Problems/0072/
---

This is very classical dynamic programming problem (there is even wikipedia page https://en.wikipedia.org/wiki/Edit_distance), which I think can not be solved without it. If I am wrong, please let me know!

Let `dp[i_1][i_2]` be the edit distance for words `dp[:i_1]` and `dp[:i_2]`. Then there can be 4 options: we can insert symbol on position `i_1` in the first word, insert symbol on position `i_2` in the second word, replace symbol `i_1` in first word with `i_2` if these symbols are different and look into `dp[i_1-1][i_2-1]` if these two symbols are the same.

**Complexity**: time complexity is `O(mn)`, and space comlexity as well. Space complexity can be improved to `O(m+n)` if we keep only current row or column.

We add stopsymbols in the beggining of words to deal with border cases in simpler way.

```
class Solution:
  def minDistance(self, word1, word2):
    word1, word2 = "!" + word1, "!" + word2
    n_1, n_2 = len(word1), len(word2)
    dp = [[0] * n_2 for _ in range(n_1)]

    for i_1 in range(n_1): dp[i_1][0] = i_1
    for i_2 in range(n_2): dp[0][i_2] = i_2

    for i_1 in range(1, n_1):
      for i_2 in range(1,n_2):
        Cost = (word1[i_1] != word2[i_2])
        dp[i_1][i_2] = min(dp[i_1-1][i_2] + 1, dp[i_1][i_2-1] + 1, dp[i_1-1][i_2-1] + Cost)

    return int(dp[-1][-1])
```