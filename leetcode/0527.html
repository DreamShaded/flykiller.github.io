<!DOCTYPE html>
<html lang="en"><head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Leetcode 0527 Word Abbreviation | Dmitry Babichev’s webpage</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Leetcode 0527 Word Abbreviation" />
<meta name="author" content="Dmitry Babichev" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Problem statement" />
<meta property="og:description" content="Problem statement" />
<meta property="og:site_name" content="Dmitry Babichev’s webpage" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-11-15T15:22:32+03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Leetcode 0527 Word Abbreviation" />
<script type="application/ld+json">
{"url":"/leetcode/0527.html","@type":"BlogPosting","headline":"Leetcode 0527 Word Abbreviation","dateModified":"2021-11-15T15:22:32+03:00","datePublished":"2021-11-15T15:22:32+03:00","mainEntityOfPage":{"@type":"WebPage","@id":"/leetcode/0527.html"},"author":{"@type":"Person","name":"Dmitry Babichev"},"description":"Problem statement","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Dmitry Babichev's webpage" />
    






  
  
</head>

    
    <!-- for mathjax support -->
    
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dmitry Babichev&#39;s webpage</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/leetcode%20problems/">Leetcode problems</a><a class="page-link" href="/coding%20ideas/">Patterns</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <span>[
  
    
    <a href="/tag/string"><code class="highligher-rouge"><nobr>string</nobr></code>&nbsp;</a>
  
    
    <a href="/tag/sort"><code class="highligher-rouge"><nobr>sort</nobr></code>&nbsp;</a>
  
    
    <a href="/tag/trie"><code class="highligher-rouge"><nobr>trie</nobr></code>&nbsp;</a>
  
]</span>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Leetcode 0527 Word Abbreviation</h1>
    <p class="post-meta"><time class="dt-published" datetime="2021-11-15T15:22:32+03:00" itemprop="datePublished">
        Nov 15, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h4 id="problem-statement">Problem statement</h4>

<p><a href="https://leetcode.com/problems/word-abbreviation/"> <font color="blue">https://leetcode.com/problems/word-abbreviation/</font></a></p>

<h4 id="solution">Solution</h4>
<p>We can have conflict, if we have equal first and last symbol and the same length. So, let us sort our <code class="language-plaintext highlighter-rouge">dic</code>, using key <code class="language-plaintext highlighter-rouge">(len(x), x[0], x[-1], x[1:-1])</code>. Now, let us traverse sorted list and for each pair of adjacent words, create abbreviations of this two words, updating <code class="language-plaintext highlighter-rouge">comm</code> value. For example, if we have words <code class="language-plaintext highlighter-rouge">abcdxxxz, abcexxxz, abcetyxz</code>, for word <code class="language-plaintext highlighter-rouge">abcexxxz</code> it have common prefix of size <code class="language-plaintext highlighter-rouge">3</code> with previous word and common prefix of size <code class="language-plaintext highlighter-rouge">4</code> with next word, so we need to use abbreviation <code class="language-plaintext highlighter-rouge">abcex2z</code>. In the end we traverse our list and check if abbreviation is built or not.</p>

<h4 id="complexity">Complexity</h4>
<p>Time complexity is <code class="language-plaintext highlighter-rouge">O(n log n * m)$, where </code>n<code class="language-plaintext highlighter-rouge"> is number of words in </code>dic<code class="language-plaintext highlighter-rouge"> and </code>m<code class="language-plaintext highlighter-rouge"> is average size of word in </code>dic<code class="language-plaintext highlighter-rouge">. Space complexity is </code>O(nm)<code class="language-plaintext highlighter-rouge"> to keep words in </code>d`.</p>

<h4 id="code">Code</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">commonprefix</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">abbr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">-</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="n">word</span>
        <span class="k">return</span> <span class="n">word</span><span class="p">[:</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">-</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">wordsAbbreviation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dic</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dic</span><span class="p">)</span>
        <span class="n">dic_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">w0</span> <span class="o">=</span> <span class="n">dic_sorted</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">w1</span> <span class="o">=</span> <span class="n">dic_sorted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">w1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">w0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">w1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">w0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">w1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">w0</span><span class="p">):</span>
                <span class="n">comm</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">commonprefix</span><span class="p">([</span><span class="n">w1</span><span class="p">,</span> <span class="n">w0</span><span class="p">]))</span> 
                <span class="n">d</span><span class="p">[</span><span class="n">w1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">w1</span><span class="p">],</span> <span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">abbr</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span> <span class="n">comm</span><span class="p">)))</span>
                <span class="n">d</span><span class="p">[</span><span class="n">w0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">w0</span><span class="p">],</span> <span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">abbr</span><span class="p">(</span><span class="n">w0</span><span class="p">,</span> <span class="n">comm</span><span class="p">)))</span>
                
        <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">d</span> <span class="k">else</span> <span class="bp">self</span><span class="p">.</span><span class="n">abbr</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="remark">Remark</h4>
<p>Instead of sorting words, we can use tries. Let us split data into groups, where inside each group we have the same starting, ending symbols and length. Then what we need to do inside each group is to find for each word the length of longest common prefix between this word and all other words, which can be done, using Tries. Note, that is not Longest Common Prefix problem, where we need to find common prefix for all strings. Here for each string, we need to return maximum of all length of common prefix between this string and each other.</p>

<p>I think complexity will be <code class="language-plaintext highlighter-rouge">O(mn)</code>, both time and space.</p>


  </div><a class="u-url" href="/leetcode/0527.html" hidden></a>
</article>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Dmitry Babichev</li>
          <li><a class="u-email" href="mailto:dimitry008@gmail.com">dimitry008@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>