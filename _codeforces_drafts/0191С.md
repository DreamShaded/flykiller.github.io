[LCA, sparse table, binary lyfting, accumulate]

1. First idea is for each query find LCA. Then we need to work with paths which go from up to down.
2. Now we can use accumulate trick: update +1 for bottom node and -1 for upper node. Then if we evaluate accumulate of this tree, we will have what we needed: for each edge answer will be this cumulative sum for lower node.
3. Also we use bootrsrap recursion trick to avoid TLE and RE

#### Complexity
Time complexity is `O(n log n + k log n)`.


#### Code
```python
from collections import defaultdict, Counter
import io, os, sys
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from types import GeneratorType


def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

class RangeQuery:
    def __init__(self, data, func=min):
        self.func = func
        self._data = _data = [list(data)]
        i, n = 1, len(_data[0])
        while 2 * i <= n:
            prev = _data[-1]
            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])
            i <<= 1

    def query(self, begin, end):
        depth = (end - begin).bit_length() - 1
        return self.func(self._data[depth][begin], self._data[depth][end - (1 << depth)])


class LCA:
    def __init__(self, root, graph):
        self.time = [-1] * len(graph)
        self.path = [-1] * len(graph)
        self.P = [-1] * len(graph)
        t = -1
        dfs = [root]
        while dfs:
            node = dfs.pop()
            self.path[t] = self.P[node]
            self.time[node] = t = t + 1
            for nei in graph[node]:
                if self.time[nei] == -1:
                    self.P[nei] = node
                    dfs.append(nei)
        self.rmq = RangeQuery(self.time[node] for node in self.path)

    def __call__(self, a, b):
        if a == b:
            return a
        a = self.time[a]
        b = self.time[b]
        if a > b:
            a, b = b, a
        return self.path[self.rmq.query(a, b)]


G = defaultdict(list)
edges = {}
d = Counter()
n = int(input())
for i in range(n-1):
    x, y = [int(x) for x in input().split()]
    G[x-1] += [y-1]
    G[y-1] += [x-1]
    edges[(x-1, y-1)] = i
    edges[(y-1, x-1)] = i

lca = LCA(0, G)
P = lca.P

k = int(input())
for _ in range(k):
    x, y = [int(x) for x in input().split()]
    z = lca(x-1, y-1)
    d[z] -= 2
    d[x-1] += 1
    d[y-1] += 1

d_acc = Counter()

@bootstrap
def dfs(par, node):
    sm = d[node]
    for child in G[node]:
        if child == par: continue
        sm += yield dfs(node, child)
    d_acc[node] = sm
    yield sm

ans = [-1]*(n-1)

dfs(-1, 0)
for x in range(1, n):
    par = P[x]
    ans[edges[x, par]] = d_acc[x]

print(" ".join(str(x) for x in ans))
```
