<!DOCTYPE html>
<html lang="en"><head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Leetcode 2045. Second Minimum Time to Reach Destination | Dmitry Babichev’s webpage</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Leetcode 2045. Second Minimum Time to Reach Destination" />
<meta name="author" content="Dmitry Babichev" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Problem statement" />
<meta property="og:description" content="Problem statement" />
<meta property="og:site_name" content="Dmitry Babichev’s webpage" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-21T11:40:43+03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Leetcode 2045. Second Minimum Time to Reach Destination" />
<script type="application/ld+json">
{"url":"/leetcode/2045.html","@type":"BlogPosting","headline":"Leetcode 2045. Second Minimum Time to Reach Destination","dateModified":"2022-01-21T11:40:43+03:00","datePublished":"2022-01-21T11:40:43+03:00","mainEntityOfPage":{"@type":"WebPage","@id":"/leetcode/2045.html"},"author":{"@type":"Person","name":"Dmitry Babichev"},"description":"Problem statement","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Dmitry Babichev's webpage" />
    






  
  
</head>

    
    <!-- for mathjax support -->
    
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dmitry Babichev&#39;s webpage</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/leetcode%20problems/">Leetcode problems</a><a class="page-link" href="/codeforces%20problems/">Codeforces problems</a><a class="page-link" href="/coding%20ideas/">Patterns</a><a class="page-link" href="/performance%20tricks/">Speed up</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <span>[
  
    
    <a href="/tag/graph"><code class="highligher-rouge"><nobr>graph</nobr></code>&nbsp;</a>
  
    
    <a href="/tag/graph algo"><code class="highligher-rouge"><nobr>graph algo</nobr></code>&nbsp;</a>
  
    
    <a href="/tag/greedy"><code class="highligher-rouge"><nobr>greedy</nobr></code>&nbsp;</a>
  
    
    <a href="/tag/bfs"><code class="highligher-rouge"><nobr>bfs</nobr></code>&nbsp;</a>
  
]</span>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Leetcode 2045. Second Minimum Time to Reach Destination</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-01-21T11:40:43+03:00" itemprop="datePublished">
        Jan 21, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h4 id="problem-statement">Problem statement</h4>

<p><a href="https://leetcode.com/problems/second-minimum-time-to-reach-destination/"> <font color="blue">https://leetcode.com/problems/second-minimum-time-to-reach-destination/</font></a></p>

<h4 id="solution">Solution</h4>
<p>To solve this problem you need to understand how Dijkstra algorithm work and adapt it to find the second shortest path. In usual Dijkstra algorithm for each node we keep shortest distance so far for this node. Here we need to keep two shortest distances. So, we keep in <code class="language-plaintext highlighter-rouge">D[node]</code> list of shortest distances for <code class="language-plaintext highlighter-rouge">node</code>.</p>

<ol>
  <li>First we traverse our <code class="language-plaintext highlighter-rouge">edges</code> and construct graph <code class="language-plaintext highlighter-rouge">G</code>.</li>
  <li>Then we do the classical Dijkstra with heap, where we extract <code class="language-plaintext highlighter-rouge">min_dist, idx = heappop(heap)</code>.</li>
  <li>We check if we already found two different distances for node <code class="language-plaintext highlighter-rouge">n</code> and if we found, return biggest distance among these two.</li>
  <li>Iterate through all neighbours and calculate distance for candidates: if we go on green light, just add <code class="language-plaintext highlighter-rouge">time</code>, if we are on the red ligth, wait for green: for the smallest time divisible by <code class="language-plaintext highlighter-rouge">2*change</code>, such that it is greater or equal to <code class="language-plaintext highlighter-rouge">min_dist</code>.</li>
  <li>Now, if we visit our <code class="language-plaintext highlighter-rouge">neib</code> for the first time, we update distance. If we visited it only once and new candidate is not equal to what we already have, add it to distances. Finally, if we already have two different distances for this node, we try to visit it only if new candidate is less than maximum (and not equal to minimum) that is we can update distances. <strong>update</strong>: in fact this condition is not needed, because we use greedy strategy here: for each node we first find the smallest distance and then the next smallest.</li>
</ol>

<h4 id="complexity">Complexity</h4>
<p>It is almost like classical Dijkstra algorithm, but now we can revisit some nodes from time to time. Time complexity is still <code class="language-plaintext highlighter-rouge">O((E + V) * log V)</code> though, because we have no more than <code class="language-plaintext highlighter-rouge">2</code> candidates, space complexity is <code class="language-plaintext highlighter-rouge">O(E + V)</code>.</p>

<h4 id="code">Code</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">secondMinimum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">change</span><span class="p">):</span>
        <span class="n">D</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">G</span><span class="p">,</span> <span class="n">heap</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">G</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="n">G</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">heap</span><span class="p">:</span>
            <span class="n">min_dist</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">neib</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">min_dist</span> <span class="o">//</span> <span class="n">change</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">cand</span> <span class="o">=</span> <span class="n">min_dist</span> <span class="o">+</span> <span class="n">time</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cand</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">min_dist</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">change</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">change</span><span class="p">)</span> <span class="o">+</span> <span class="n">time</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">D</span><span class="p">[</span><span class="n">neib</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">neib</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">D</span><span class="p">[</span><span class="n">neib</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[</span><span class="n">cand</span><span class="p">]):</span>
                    <span class="n">D</span><span class="p">[</span><span class="n">neib</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cand</span><span class="p">]</span>
                    <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">neib</span><span class="p">))</span>
</code></pre></div></div>

  </div><a class="u-url" href="/leetcode/2045.html" hidden></a>
</article>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Dmitry Babichev</li>
          <li><a class="u-email" href="mailto:dimitry008@gmail.com">dimitry008@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>